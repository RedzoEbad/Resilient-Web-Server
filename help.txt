Kubernetes Deployment â€” Easy Explanation
1ï¸âƒ£ What is a Kubernetes Deployment?

A Deployment is a Kubernetes object that:

Runs your application

Decides how many pods should run

Decides which container image to use

Automatically updates, scales, and rolls back your app

ğŸ‘‰ You tell Kubernetes what you want, and Kubernetes makes it happen.

2ï¸âƒ£ Why do we need Deployments?

Without Deployment, updating an app is hard:

Stop old pod

Start new pod

Check if it works

Roll back if it fails

âŒ Doing this manually causes:

Human mistakes

Downtime

Slow releases

âœ… Deployment automates everything.

3ï¸âƒ£ What Deployment does for you

A Deployment can:

Create Pods (via ReplicaSet)

Keep the required number of pods always running

Update pods safely

Roll back to older versions

Scale up or down

Pause and resume updates

4ï¸âƒ£ Desired State (Very Important Concept)

Kubernetes works on desired state.

You say:

replicas: 3
image: myapp:v2


Kubernetes ensures:

3 pods are always running

They are using myapp:v2

If a pod crashes â†’ Kubernetes recreates it automatically.

5ï¸âƒ£ Deployment Strategies (How updates happen)
ğŸ” Rolling Update (Default)

Pods are updated one by one

No downtime

Old and new versions run together for some time

Rules:

Max 25% pods can be down

Max 25% extra pods can be created

âœ… Best for production
âŒ App must handle mixed versions

ğŸ”„ Recreate Strategy

All old pods are stopped

Then new pods start

âŒ Causes downtime
âœ… Simple (only one version runs)

Best for:

Non-production

Apps that cannot run multiple versions

6ï¸âƒ£ Updating a Deployment

You change the pod template (image, env, config).

Example:

image: myapp:v3


Kubernetes automatically:

Starts rollout

Tracks progress

Saves previous versions

7ï¸âƒ£ Rollout Lifecycle

A deployment can be:

Progressing â†’ updating pods

Complete â†’ everything successful

Failed â†’ error happened

Check status:

kubectl rollout status deployment my-app

8ï¸âƒ£ Rollback (Very Important)

If a new version fails:

kubectl rollout undo deployment my-app


â¡ï¸ Instantly returns to previous working version.

9ï¸âƒ£ Declarative Deployment (Key Idea)

You write a YAML file that describes:

How the app should look

How many pods

Which image

Then run:

kubectl apply -f deployment.yaml


Kubernetes keeps enforcing that state.

ğŸ”‘ MOST IMPORTANT POINTS (Exam / Interview)

Deployment manages Pods indirectly via ReplicaSet

It maintains desired state

Supports rolling updates and rollback

Rolling update = no downtime

Recreate = downtime but simpler

Fully automated by Kubernetes

Changes to pod template trigger rollout

ğŸ§  One-line brain-lock

A Kubernetes Deployment automates running, updating, scaling, and rolling back applications while always keeping the desired number of pods running.




ğŸ” Kubernetes Deployment â€“ Commands (Step by Step)
ğŸ”¹ STEP 1: Create a Deployment (Start the app)
Command:
kubectl apply -f deployment.yaml

What it does:

Sends your YAML to Kubernetes

Kubernetes creates:

Deployment

ReplicaSet

Pods

ğŸ§  This is how your app starts running

ğŸ”¹ STEP 2: Verify Deployment is created
Command:
kubectl get deployments

What it does:

Shows all deployments

Displays:

Desired replicas

Available replicas

ğŸ”¹ STEP 3: Check Pods created by Deployment
Command:
kubectl get pods

What it does:

Lists running pods

Confirms pods are up and running

ğŸ”¹ STEP 4: Get detailed Deployment info
Command:
kubectl describe deployment my-app

What it does:

Shows:

Image version

Update strategy

Events (errors, restarts)

ğŸ§  Most useful debugging command

ğŸ”¹ STEP 5: Expose the Deployment (Make app accessible)
Command:
kubectl expose deployment my-app --type=NodePort --port=80

What it does:

Creates a Service

Allows external traffic to reach pods

ğŸ”¹ STEP 6: Scale the Deployment
Command:
kubectl scale deployment my-app --replicas=5

What it does:

Increases or decreases number of pods

Kubernetes auto-creates or deletes pods

ğŸ”¹ STEP 7: Update the application (Rolling Update)
Method 1: Change YAML & apply again
kubectl apply -f deployment.yaml

Method 2: Change image directly
kubectl set image deployment my-app my-container=myapp:v2

What happens:

Rolling update starts

Old pods replaced gradually

ğŸ”¹ STEP 8: Monitor rollout progress
Command:
kubectl rollout status deployment my-app

What it does:

Shows rollout progress

Tells if update is successful or stuck

ğŸ”¹ STEP 9: View rollout history
Command:
kubectl rollout history deployment my-app

What it does:

Shows previous versions

Useful before rollback

ğŸ”¹ STEP 10: Rollback if update fails
Command:
kubectl rollout undo deployment my-app

Or rollback to specific version:
kubectl rollout undo deployment my-app --to-revision=2

What it does:

Restores previous working version

ğŸ”¹ STEP 11: Pause a Deployment
Command:
kubectl rollout pause deployment my-app

What it does:

Stops updates temporarily

ğŸ”¹ STEP 12: Resume Deployment
Command:
kubectl rollout resume deployment my-app

ğŸ”¹ STEP 13: Check logs of pods
Command:
kubectl logs <pod-name>

Why:

Debug app errors

Verify app behavior

ğŸ”¹ STEP 14: Exec into a pod (Debug inside container)
Command:
kubectl exec -it <pod-name> -- /bin/sh

Why:

Check files

Test configs

Debug runtime issues

ğŸ”¹ STEP 15: Delete Deployment (Clean up)
Command:
kubectl delete deployment my-app

What it does:

Deletes deployment

Automatically deletes ReplicaSet & Pods

ğŸ§  FULL FLOW (Mind-lock)
apply â†’ get â†’ describe â†’ expose
      â†’ scale â†’ update â†’ rollout status
      â†’ rollback (if needed)
      â†’ delete

âœ… MOST IMPORTANT COMMANDS (Interview Focus)
Purpose	Command
Create	kubectl apply
Scale	kubectl scale
Update	kubectl set image
Monitor	kubectl rollout status
Rollback	kubectl rollout undo
ğŸ”‘ One-line summary

Kubernetes Deployment commands allow you to create, update, scale, monitor, and rollback applications in a safe and automated way.